\documentclass[uplatex]{jsarticle}
\usepackage{listings, jlisting}
\lstset{
  basicstyle={\ttfamily},
  identifierstyle={\small},
  commentstyle={\smallitshape},
  keywordstyle={\small\bfseries},
  ndkeywordstyle={\small},
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},
  numbers=left,
  xrightmargin=0zw,
  xleftmargin=3zw,
  numberstyle={\scriptsize},
  stepnumber=1,
  numbersep=1zw,
  lineskip=-0.5ex
}
\usepackage[dvipdfmx]{graphicx}
\title{コンピュータ科学実験3}

\author{101730153 佐治 礼仁 saji.ayahito@h.mbox.nagoya-u.ac.jp}
\date{\today}
\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section{言語仕様}
はじめに，この実験を通して作成する言語の仕様を記述する．この実験で作成する言語はプログラム言語Pascalのサブ接である．実験では，まず基本的な機能を実奏し，順次，他の機能を追加課題として加える方式を採用した．それによって，段階を踏んで，実際的なプログラミング言語を開発することが可能である．
実験1から実験3までで作成するコンパイラが対応する言語は\verb#PL-0#と定義する．これに段階的に機能を追加していったものを\verb#PL-1#から\verb#PL-3#と呼称する．
\subsection{PL-0}
プログラミング言語\verb#PL-0#は次のような仕様である．
\begin{itemize}
  \item データ型は整数型のみ存在する．
  \item 手続きおよび再帰呼出しが可能．
  \item 名前（変数名と手続き名）の有効範囲は標準Pascalと同等である．ただし，手続き定義の入れ子の深さは1までとする．したがって，手続きの中で他の手続きを定義することはできない．
  \item 制御文は次の4種類を定義する．
  \begin{itemize}
    \item \verb#if ... then ... else ...# 条件分岐文
    \item \verb#while ... do ... # whileループ文
    \item \verb#for ... do ...# forループ文
    \item \verb#begin ..; ..; end# 複合文
  \end{itemize}
  \item 入出力のための命令文として\verb#read#，\verb#write#が存在する．
\end{itemize}
\subsection{PL-1}
プログラミング言語\verb#PL-1#は次のような仕様である．
\begin{itemize}
  \item データ型は整数型のみ存在する．
  \item 手続きおよび再帰呼出しが可能，この時引数の値渡しが可能である．引数は複数でも良い．
  \item 名前（変数名と手続き名）の有効範囲は標準Pascalと同等である．ただし，手続き定義の入れ子の深さは1までとする．したがって，手続きの中で他の手続きを定義することはできない．
  \item 制御文は次の4種類を定義する．
  \begin{itemize}
    \item \verb#if ... then ... else ...# 条件分岐文
    \item \verb#while ... do ... # whileループ文
    \item \verb#for ... do ...# forループ文
    \item \verb#begin ..; ..; end# 複合文
  \end{itemize}
  \item 入出力のための命令文として\verb#read#，\verb#write#が存在する．
\end{itemize}
\subsection{PL-2}
プログラミング言語\verb#PL-2#は次のような仕様である．
\begin{itemize}
  \item データ型は整数型のみ存在する．
  \item 手続きおよび再帰呼出しが可能，この時引数の値渡しが可能である．引数は複数でも良い．手続きに戻り値を定義可能であり，関数として処理することが可能である．
  \item 名前（変数名と手続き名）の有効範囲は標準Pascalと同等である．ただし，手続き定義の入れ子の深さは1までとする．したがって，手続きの中で他の手続きを定義することはできない．
  \item 制御文は次の4種類を定義する．
  \begin{itemize}
    \item \verb#if ... then ... else ...# 条件分岐文
    \item \verb#while ... do ... # whileループ文
    \item \verb#for ... do ...# forループ文
    \item \verb#begin ..; ..; end# 複合文
  \end{itemize}
  \item 入出力のための命令文として\verb#read#，\verb#write#が存在する．
\end{itemize}
\subsection{PL-3}
プログラミング言語\verb#PL-3#は次のような仕様である．
\begin{itemize}
  \item データ型は整数型のみ存在する．
  \item 手続きおよび再帰呼出しが可能，この時引数の値渡しが可能である．引数は複数でも良い．手続きに戻り値を定義可能であり，関数として処理することが可能である．
  \item 名前（変数名と手続き名）の有効範囲は標準Pascalと同等である．ただし，手続き定義の入れ子の深さは1までとする．したがって，手続きの中で他の手続きを定義することはできない．
  \item 制御文は次の4種類を定義する．
  \begin{itemize}
    \item \verb#if ... then ... else ...# 条件分岐文
    \item \verb#while ... do ... # whileループ文
    \item \verb#for ... do ...# forループ文
    \item \verb#begin ..; ..; end# 複合文
  \end{itemize}
  \item 入出力のための命令文として\verb#read#，\verb#write#が存在する．
  \item 1次元の配列を扱うことが可能である．配列の開始番号および添字の範囲は自由に設定可能である．
\end{itemize}
\section{実験1}
\subsection{目的}
この実験では，字句解析器生成器の一つである\verb#lex#を用いて，PL0言語を字句解析するCプログラム\verb#scanner.c#を生成する．
実験の目的は，\verb#lex#の使い方および，PL0言語がどのように規定されるかを正しく理解することである．コンパイラ作成において，構文解析が重要な要素であるが，字句解析は構文解析を行うための前提として不可欠である．ここでは，規定されていないトークンが入力された際に，エラーを正しく返すプログラムを目標として作成する．
\subsection{実験方法}
この実験では，作成する\verb#PL-0#コンパイラが解析する言語が対応するトークン列を字句解析するプログラム\verb#scanner.l#を作成する．
ここで，\verb#PL-0#コンパイラが解析する言語\verb#PL-0#のトークンを表\ref{tbl:token}に記述する．
\begin{table}[tb]
  \begin{center}
    \caption{トークン表}
    \begin{tabular}{|l|l|l|} \hline
      記号 & 種別 & 列挙型名 \\ \hline \hline
      \verb#begin# & 予約語 & \verb#SBEGIN# \\
      \verb#div# & 予約語 & \verb#DIV# \\
      \verb#do# & 予約語 & \verb#DO# \\
      \verb#else# & 予約語 & \verb#ELSE# \\
      \verb#end# & 予約語 & \verb#SEND# \\
      \verb#for# & 予約語 & \verb#FOR# \\
      \verb#forward# & 予約語 & \verb#FORWARD# \\
      \verb#function# & 予約語 & \verb#FUNCTION# \\
      \verb#if# & 予約語 & \verb#IF# \\
      \verb#procedure# & 予約語 & \verb#PROCEDURE# \\
      \verb#program# & 予約語 & \verb#PROGRAM# \\
      \verb#read# & 予約語 & \verb#READ# \\
      \verb#then# & 予約語 & \verb#THEN# \\
      \verb#to# & 予約語 & \verb#TO# \\
      \verb#var# & 予約語 & \verb#VAR# \\
      \verb#while# & 予約語 & \verb#WHILE# \\
      \verb#write# & 予約語 & \verb#WRITE# \\
      \hline
      \verb#+# & 基本シンボル & \verb#PLUS# \\
      \verb#-# & 基本シンボル & \verb#MINUS# \\
      \verb#*# & 基本シンボル & \verb#MULT# \\
      \verb#=# & 基本シンボル & \verb#EQ# \\
      \verb#<># & 基本シンボル & \verb#NEQ# \\
      \verb#<=# & 基本シンボル & \verb#LE# \\
      \verb#<# & 基本シンボル & \verb#LT# \\
      \verb#>=# & 基本シンボル & \verb#GE# \\
      \verb#># & 基本シンボル & \verb#GT# \\
      \verb#(# & 基本シンボル & \verb#LPAREN# \\
      \verb#)# & 基本シンボル & \verb#RPAREN# \\
      \verb#[# & 基本シンボル & \verb#LBRACE# \\
      \verb#]# & 基本シンボル & \verb#RBRACE# \\
      \verb#,# & 基本シンボル & \verb#COMMA# \\
      \verb#;# & 基本シンボル & \verb#SEMICOLON# \\
      \verb#:# & 基本シンボル & \verb#COLON# \\
      \verb#.# & 基本シンボル & \verb#PERIOD# \\
      \verb#..# & 基本シンボル & \verb#INTERVAL# \\
      \verb#:=# & 基本シンボル & \verb#ASSIGN# \\
      \hline
    \end{tabular}
    \label{tbl:token}
  \end{center}
\end{table}
実験開始時に配布された\verb#src.zip#をlinuxマシン上で解凍すると，\verb#data-structure.c#，\verb#parser.y#，\verb#scanner.l#および\verb#symbol.h#が出力される．実験1で利用するファイルは\verb#scanner.l#および\verb#symbol.h#である．これらのファイルはルールの一部が適切に設定されておらず，トークン列にたいして正しく動作しないため，ルールを正しく追加定義した．
正しく変更した\verb#scanner.l#をソースコード\ref{lst:ex1:scanner.l}に記述する．検出したトークンに対して，返すシンボル列が\verb#symbols.h#に定義されているため，この定義に従って行った．\verb#symbols.h#のプログラムをソースコード\ref{lst:ex1:symbols.h}に記載する．
\begin{lstlisting}[caption=symbol.h,label=lst:ex1:symbols.h]
/*
 * symbols.h
 */

enum {
    SBEGIN = 1,                  /* begin */
    DIV,
    DO,
    ELSE,
    END,                       /* end */
    FOR,
    FORWARD,
    FUNCTION,
    IF,
    PROCEDURE,
    PROGRAM,
    READ,
    THEN,
    TO,
    VAR,
    WHILE,
    WRITE,

    PLUS,
    MINUS,
    MULT,
    EQ,                         /* = */
    NEQ,                        /* <> */
    LE,                         /* <= */
    LT,                         /* < */
    GE,                         /* >= */
    GT,                         /* > */
    LPAREN,                     /* ( */
    RPAREN,                     /* ) */
    LBRACE,                     /* [ */
    RBRACE,                     /* ] */
    COMMA,
    SEMICOLON,
    COLON,
    INTERVAL,                   /* .. */
    PERIOD,
    ASSIGN,                     /* := */
    NUMBER,
    IDENT,
};
\end{lstlisting}
\begin{lstlisting}[caption=scanner.l,label=lst:ex1:scanner.l]
%{
/*
 * scanner: scanner for PL-*
 *
 */

#include <stdio.h>
#include <string.h>
#include "symbols.h"

#define MAXLENGTH 16

typedef union {
    int num;
    char ident[MAXLENGTH+1];
} token;

/*
 * yylval という変数名にするのは，yacc との融合時にプログラムの変更を
 * 最小限にするためである．
 */
token yylval;

%}
%option yylineno
%%

begin           return SBEGIN;
div             return DIV;
do              return DO;
else            return ELSE;
end             return END;
for             return FOR;
forward         return FORWARD;
function        return FUNCTION;
if              return IF;
procedure       return PROCEDURE;
program         return PROGRAM;
read            return READ;
then            return THEN;
to              return TO;
var             return VAR;
while           return WHILE;
write           return WRITE;

"+"             return PLUS;
"-"             return MINUS;
"*"             return MULT;
"="             return EQ;
"<>"            return NEQ;
"<="            return LE;
"<"             return LT;
">="            return GE;
">"             return GT;
"("             return LPAREN;
")"             return RPAREN;
"["             return LBRACE;
"]"             return RBRACE;
","             return COMMA;
";"             return SEMICOLON;
":"             return COLON;
".."            return INTERVAL;
"."             return PERIOD;
":="            return ASSIGN;

[0-9]|[1-9][0-9]* {
    yylval.num = atoi(yytext);
    return NUMBER;
}

[a-zA-Z][0-9a-zA-Z]* {
    strcpy(yylval.ident, yytext);
    return IDENT;
}

[ \t\n] ;

. {
    fprintf(stderr, "cannot handle such characters: %s\n", yytext);
}

%%

main(int argc, char *argv[]) {
    FILE *fp;
    int tok;

    if (argc != 2) {
        fprintf(stderr, "usage: %s filename\n", argv[0]);
        exit(1);
    }

    if ((fp = fopen(argv[1], "r")) == NULL) {
        fprintf(stderr, "cannot open file: %s\n", argv[1]);
        exit(1);
    }

    /*
     * yyin は lex の内部変数であり，入力のファイルポインタを表す．
     */
    yyin = fp;

    /*
     * yylex() を呼び出すことにより，トークンが一つ切り出される．
     * yylex() の戻り値は，上のアクション部で定義した戻り値である．
     * yytext には，切り出されたトークンが文字列として格納されている．
     */
    while (tok = yylex()) {
        switch (tok) {
        case NUMBER:
            printf("\"%s\":\t%d\t%d\n", yytext, tok, yylval.num);
            break;

        case IDENT:
            printf("\"%s\":\t%d\t%s\n", yytext, tok, yylval.ident);
            break;

        default:
            printf("\"%s\":\t%d\tRESERVE\n", yytext, tok);
            break;
        }
    }
}
\end{lstlisting}
ルールを適切に追加定義したら，コマンド\ref{lst:ex1:scanner}で\verb#lex#および\verb#cc#を用いてコンパイルし，実行可能ファイルである\verb#scanner#を作成した．
\begin{lstlisting}[caption=字句解析器scanner.lの生成コマンド,label=lst:ex1:scanner]
$lex scanner.l
$cc lex.yy.c -ll -o scanner
\end{lstlisting}
また，\verb#scanner#の作成は今後行う回数が多いため，\verb#Makefile#を作成して，次のように記述した．
\begin{lstlisting}[caption=Makefile,label=lst:ex1:makefile]
lex:
	lex scanner.l
	cc lex.yy.c -ll -o scanner
\end{lstlisting}
そのため，今後は\verb#make#コマンドを用いてコンパイルを行った．
ダウンロード\verb#src#フォルダに，実験開始時に与えられたサンプルプログラム集\verb#samples.zip#を保存して解凍した．
その後\verb#scanner#を用いて字句解析を行った．
\subsection{実験結果}
\verb#scanner#での字句解析の結果を示す．
この実験では\verb#pl0a.p#，\verb#pl0b.p#，\verb#pl0c.p#，\verb#pl1a.p#，\verb#pl2a.p#，\verb#pl2b.p#，\verb#pl2c.p#，\verb#pl3a.p#，\verb#pl3b.p#を字句解析を行った．
ソースコード\ref{lst:ex1:result-pl0a.p}およびソースコード\ref{lst:ex1:result-pl0b.p}にそれぞれ\verb#pl0a.p#，\verb#pl0b.p#の結果を記載する．
一列目はトークンとして認識された文字列，二列目はトークン番号，三番目はトークンの値または予約語を示している．
\begin{lstlisting}[caption=pl0a.pの字句解析結果,label=lst:ex1:result-pl0a.p]
$./scanner samples/pl0a.p
"program":	11	RESERVE
"PL0A":	38	PL0A
";":	32	RESERVE
"var":	15	RESERVE
"n":	38	n
",":	31	RESERVE
"sum":	38	sum
";":	32	RESERVE
"begin":	1	RESERVE
"n":	38	n
":=":	36	RESERVE
"10":	37	10
";":	32	RESERVE
"sum":	38	sum
":=":	36	RESERVE
"0":	37	0
";":	32	RESERVE
"while":	16	RESERVE
"n":	38	n
">":	26	RESERVE
"0":	37	0
"do":	3	RESERVE
"begin":	1	RESERVE
"sum":	38	sum
":=":	36	RESERVE
"sum":	38	sum
"+":	18	RESERVE
"n":	38	n
";":	32	RESERVE
"n":	38	n
":=":	36	RESERVE
"n":	38	n
"-":	19	RESERVE
"1":	37	1
"end":	5	RESERVE
"end":	5	RESERVE
".":	35	RESERVE
\end{lstlisting}

\begin{lstlisting}[caption=pl0b.pの字句解析結果,label=lst:ex1:result-pl0b.p]
$./scanner samples/pl0b.p
"program":	11	RESERVE
"PL0B":	38	PL0B
";":	32	RESERVE
"var":	15	RESERVE
"n":	38	n
",":	31	RESERVE
"x":	38	x
";":	32	RESERVE
"procedure":	10	RESERVE
"prime":	38	prime
";":	32	RESERVE
"var":	15	RESERVE
"m":	38	m
";":	32	RESERVE
"begin":	1	RESERVE
"m":	38	m
":=":	36	RESERVE
"x":	38	x
"div":	2	RESERVE
"2":	37	2
";":	32	RESERVE
"while":	16	RESERVE
"x":	38	x
"<>":	22	RESERVE
"(":	27	RESERVE
"x":	38	x
"div":	2	RESERVE
"m":	38	m
")":	28	RESERVE
"*":	20	RESERVE
"m":	38	m
"do":	3	RESERVE
"m":	38	m
":=":	36	RESERVE
"m":	38	m
"-":	19	RESERVE
"1":	37	1
";":	32	RESERVE
"if":	9	RESERVE
"m":	38	m
"=":	21	RESERVE
"1":	37	1
"then":	13	RESERVE
"write":	17	RESERVE
"(":	27	RESERVE
"x":	38	x
")":	28	RESERVE
"end":	5	RESERVE
";":	32	RESERVE
"begin":	1	RESERVE
"read":	12	RESERVE
"(":	27	RESERVE
"n":	38	n
")":	28	RESERVE
";":	32	RESERVE
"while":	16	RESERVE
"1":	37	1
"<":	24	RESERVE
"n":	38	n
"do":	3	RESERVE
"begin":	1	RESERVE
"x":	38	x
":=":	36	RESERVE
"n":	38	n
";":	32	RESERVE
"prime":	38	prime
";":	32	RESERVE
"n":	38	n
":=":	36	RESERVE
"n":	38	n
"-":	19	RESERVE
"1":	37	1
"end":	5	RESERVE
"end":	5	RESERVE
".":	35	RESERVE
\end{lstlisting}
上記の結果より，適切に字句解析が行われていることが確認できた．

\subsection{考察}
字句解析は，正規表現を利用して文字列からトークンと呼ばれる単語を切り出し，並べてトークン列を生成する処理である．
プログラムのソースコードは，もともとただの文字列である．したがって，コンパイラとは，文字列（が書き込まれたファイル）を受け取り，実行可能なバイナリファイルを出力するプログラムだと考えられる．

字句解析は，コンパイラの最初の機能である．\verb#lex#はOSSの一つであり，\verb#flex#と呼ばれる後継が存在するが，いまだにRuby等のプログラミング言語の作成に使用されている．正規表現のルールを上から検証して，切り出された文字列がルールに適用できればトークンとして記号列に追加する．というようになっている．
このプログラム言語\verb#PL-0#では，いくつかの予約語およびいくつかのシンボル，そして数字が存在する．\verb#lex#では，トークンには，トークンの種別とトークンの値という概念が存在する．例えば，10というトークンと101というトークンは値は異なるトークンである．一方，構文解析時には同じ数字として処理した方が簡潔にコードがかけることが容易に考えられる．したがって，これらは同じ「数字」というトークン種別で扱えるようになっている．これは\verb#yacc#で構文解析する際に役立つ．

\section{実験2}
\subsection{目的}
この実験の目的は，\verb#PL-0#の構文解析器である\verb#parser#を\verb#yacc#を用いて作成することである．
\verb#yacc#で用いる構文規則はBNF記法を参考に構成されており，文法がBNF記法で与えられるプログラミング言語を実装するのに都合が良い．\verb#PL-0#は文法がBNF記法で与えることが可能であり，\verb#yacc#で言語を容易に構文規則を実装することができる．
この実験を通して，\verb#yacc#の使用方法ならびにBNF記法の仕組みについて考え，\verb#PL-0#の構文規則に対して理解を深める．加えて，\verb#yacc#と\verb#lex#を組み合わせる方法についても学習する．
\subsection{実験方法}
実験開始時に提供された\verb#src#フォルダ中に存在する\verb#parser.y#は，\verb#PL-0#の構文規則が適切に定義されていない．まず，\verb#parser.y#中に適切に構文規則を追加定義した．構文規則は\%\%で囲まれた構文規則部に記述した．
追加定義はソースコード\verb#lst:ex2:bnf#に記載した．

\begin{lstlisting}[caption=構文規則の追加定義,label=lst:ex2:bnf]
program
        : PROGRAM IDENT SEMICOLON outblock PERIOD
        ;

outblock
        : var_decl_part subprog_decl_part statement
        ;

var_decl_part
        : /* empty */
        | var_decl_list SEMICOLON
        ;

var_decl_list
        : var_decl_list SEMICOLON var_decl
        | var_decl
        ;

var_decl
        : VAR id_list
        ;

subprog_decl_part
        : subprog_decl_list SEMICOLON
        | /* empty */
        ;

subprog_decl_list
        : subprog_decl_list SEMICOLON subprog_decl
        | subprog_decl
        ;

subprog_decl
        : proc_decl
        ;

proc_decl
        : PROCEDURE proc_name SEMICOLON inblock
        ;

proc_name
        : IDENT
        ;

inblock
        : var_decl_part statement
        ;

statement_list
        : statement_list SEMICOLON statement
        | statement
        ;

statement
        : assignment_statement
        | if_statement
        | while_statement
        | for_statement
        | proc_call_statement
        | null_statement
        | block_statement
        | read_statement
        | write_statement
        ;

assignment_statement
        : IDENT ASSIGN expression
        ;

if_statement
        : IF condition THEN statement else_statement
        ;

else_statement
        : ELSE statement
        |
        ;

while_statement
        : WHILE condition DO statement
        ;

for_statement
        : FOR IDENT ASSIGN expression TO expression DO statement
        ;

proc_call_statement
        : proc_call_name
        ;

proc_call_name
        : IDENT
        ;

block_statement
        : SBEGIN statement_list SEND
        ;

read_statement
        : READ LPAREN IDENT RPAREN
        ;

write_statement
        : WRITE LPAREN IDENT RPAREN
        ;

null_statement
        : /*empty*/
        ;

condition
        : expression EQ expression
        | expression NEQ expression
        | expression LT expression
        | expression LE expression
        | expression GT expression
        | expression GE expression
        ;

expression
        : term
        | PLUS term
        | MINUS term
        | expression PLUS term
        | expression MINUS term
        ;

term
        : factor
        | term MULT factor
        | term DIV factor
        ;

factor
        : var_name
        | NUMBER
        | LPAREN expression RPAREN
        ;

var_name
        : IDENT
        ;

arg_list
        : expression
        | arg_list COMMA expression
        ;

id_list
        : IDENT
        | id_list COMMA IDENT
\end{lstlisting}
次に，\verb#parser.y#と\verb#scanner.l#を適切に結合して，２つのプログラムで強調して字句解析および構文解析を行うようにプログラムを編集した．まずは\verb#scanner.l#の変更をソースコードに示す．ここでは，includeしている\verb#symbols.h#を，\verb#y.tab.h#に変更した．\verb#y.tab.h#は\verb#parser.y#を\verb#yacc#コマンドによってコンパイルすると生成されるヘッダファイルである．ここに字句解析に必要なデータが定義される．また，\verb#y.tab.h#と\verb#define#部の順番に気をつけて読み込みを行った．
次に，\verb#main#関数内で\verb#yyparse#関数を呼び出すことで，構文解析を字句解析と同時に行うようにした．また，実験1で利用した，字句の種類および値を出力する部分のコードはコメントアウトした．
これをソースコード\ref{lst:ex2:scanner.l}に示す．
\begin{lstlisting}[caption=scanner.lの修正,label=lst:ex2:scanner.l]
%{
/*
 * scanner: scanner for PL-*
 *
 */

#include <stdio.h>
#include <string.h>
// #include "symbols.h"

#define MAXLENGTH 16

#include "y.tab.h"

/*
typedef union {
    int num;
    char ident[MAXLENGTH+1];
} token;
*/

/*
 * yylval という変数名にするのは，yacc との融合時にプログラムの変更を
 * 最小限にするためである．
 */
/*
token yylval;
*/

%}
%option yylineno
%%

begin           return SBEGIN;
div             return DIV;
do              return DO;
else            return ELSE;
end             return SEND;
for             return FOR;
forward         return FORWARD;
function        return FUNCTION;
if              return IF;
procedure       return PROCEDURE;
program         return PROGRAM;
read            return READ;
then            return THEN;
to              return TO;
var             return VAR;
while           return WHILE;
write           return WRITE;

"+"             return PLUS;
"-"             return MINUS;
"*"             return MULT;
"="             return EQ;
"<>"            return NEQ;
"<="            return LE;
"<"             return LT;
">="            return GE;
">"             return GT;
"("             return LPAREN;
")"             return RPAREN;
"["             return LBRACE;
"]"             return RBRACE;
","             return COMMA;
";"             return SEMICOLON;
":"             return COLON;
".."            return INTERVAL;
"."             return PERIOD;
":="            return ASSIGN;

[0-9]|[1-9][0-9]* {
    yylval.num = atoi(yytext);
    return NUMBER;
}

[a-zA-Z][0-9a-zA-Z]* {
    strcpy(yylval.ident, yytext);
    return IDENT;
}

[ \t\n] ;

. {
    fprintf(stderr, "cannot handle such characters: %s\n", yytext);
}

%%

main(int argc, char *argv[]) {
    FILE *fp;
    int tok;

    if (argc != 2) {
        fprintf(stderr, "usage: %s filename\n", argv[0]);
        exit(1);
    }

    if ((fp = fopen(argv[1], "r")) == NULL) {
        fprintf(stderr, "cannot open file: %s\n", argv[1]);
        exit(1);
    }

    /*
     * yyin は lex の内部変数であり，入力のファイルポインタを表す．
     */
    yyin = fp;

    yyparse();

    /*
     * yylex() を呼び出すことにより，トークンが一つ切り出される．
     * yylex() の戻り値は，上のアクション部で定義した戻り値である．
     * yytext には，切り出されたトークンが文字列として格納されている．
     */
    /*
    while (tok = yylex()) {
        switch (tok) {
        case NUMBER:
            printf("\"%s\":\t%d\t%d\n", yytext, tok, yylval.num);
            break;

        case IDENT:
            printf("\"%s\":\t%d\t%s\n", yytext, tok, yylval.ident);
            break;

        default:
            printf("\"%s\":\t%d\tRESERVE\n", yytext, tok);
            break;
        }
    }
    */
}

\end{lstlisting}

構文解析中にエラーを出力するために，エラーの行番号\verb#yylineno#およびエラー発生トークン\verb#yytext#を宣言し，\verb#yyerror#関数中で，エラーの行番号およびエラー発生トークンを利用して，エラー表示を行うように\verb#parser.y#を変更した．
変更した\verb#parser.y#をソースコード\ref{lst:ex2:parser.y}に示す．

\begin{lstlisting}[caption=parser.yの修正,label=lst:ex2:parser.y]
%{
/*
 * parser; Parser for PL-*
 */

#define MAXLENGTH 16

#include <stdio.h>

extern int yylineno;
extern char *yytext;

%}

%union {
    int num;
    char ident[MAXLENGTH+1];
}

%token SBEGIN DO ELSE SEND
%token FOR FORWARD FUNCTION IF PROCEDURE
%token PROGRAM READ THEN TO VAR
%token WHILE WRITE

%left PLUS MINUS                       //← 注意
%left MULT DIV                         //← 注意

%token EQ NEQ LE LT GE GT
%token LPAREN RPAREN LBRACE RBRACE
%token COMMA SEMICOLON COLON INTERVAL
%token PERIOD ASSIGN
%token <num> NUMBER                    //← yylval の型を指定
%token <ident> IDENT                   //← yylval の型を指定

%%

program
        : PROGRAM IDENT SEMICOLON outblock PERIOD
        ;

outblock
        : var_decl_part subprog_decl_part statement
        ;

var_decl_part
        : /* empty */
        | var_decl_list SEMICOLON
        ;

var_decl_list
        : var_decl_list SEMICOLON var_decl
        | var_decl
        ;

var_decl
        : VAR id_list
        ;

subprog_decl_part
        : subprog_decl_list SEMICOLON
        | /* empty */
        ;

subprog_decl_list
        : subprog_decl_list SEMICOLON subprog_decl
        | subprog_decl
        ;

subprog_decl
        : proc_decl
        ;

proc_decl
        : PROCEDURE proc_name SEMICOLON inblock
        ;

proc_name
        : IDENT
        ;

inblock
        : var_decl_part statement
        ;

statement_list
        : statement_list SEMICOLON statement
        | statement
        ;

statement
        : assignment_statement
        | if_statement
        | while_statement
        | for_statement
        | proc_call_statement
        | null_statement
        | block_statement
        | read_statement
        | write_statement
        ;

assignment_statement
        : IDENT ASSIGN expression
        ;

if_statement
        : IF condition THEN statement else_statement
        ;

else_statement
        : ELSE statement
        |
        ;

while_statement
        : WHILE condition DO statement
        ;

for_statement
        : FOR IDENT ASSIGN expression TO expression DO statement
        ;

proc_call_statement
        : proc_call_name
        ;

proc_call_name
        : IDENT
        ;

block_statement
        : SBEGIN statement_list SEND
        ;

read_statement
        : READ LPAREN IDENT RPAREN
        ;

write_statement
        : WRITE LPAREN IDENT RPAREN
        ;

null_statement
        : /*empty*/
        ;

condition
        : expression EQ expression
        | expression NEQ expression
        | expression LT expression
        | expression LE expression
        | expression GT expression
        | expression GE expression
        ;

expression
        : term
        | PLUS term
        | MINUS term
        | expression PLUS term
        | expression MINUS term
        ;

term
        : factor
        | term MULT factor
        | term DIV factor
        ;

factor
        : var_name
        | NUMBER
        | LPAREN expression RPAREN
        ;

var_name
        : IDENT
        ;

arg_list
        : expression
        | arg_list COMMA expression
        ;

id_list
        : IDENT
        | id_list COMMA IDENT

%%
yyerror(char *s)
{
  fprintf(stderr, "%s(%d: \'%s\')\n", s, yylineno, yytext);
}

\end{lstlisting}

\verb#parser.y#および\verb#scanner.l#を連携して実行するため，\verb#Makefile#を編集した．編集結果をソースコード\ref{lst:ex2:makefile}に示す．
コンパイラ，構文解析ツールおよび字句解析ツールは編集しやすいように変数化した．\verb#make#コマンドによって，実行可能な\verb#parser#ファイルを作成することができるようにした．
\begin{lstlisting}[caption=Makefileの修正,label=lst:ex2:makefile]
CC = cc
LEX = lex
YACC = yacc -d

parser: y.tab.c lex.yy.c
	$(CC) y.tab.c lex.yy.c -ll -o parser

lex.yy.c: scanner.l
	$(LEX) scanner.l

scanner: lex.yy.c
	$(CC) lex.yy.c -ll -o scanner

y.tab.c: parser.y
	$(YACC) parser.y

clean:
	rm -rf *.o

\end{lstlisting}
出力される実行可能ファイル\verb#parser#を用いて，サンプルプログラムの構文解析が正しく行えるかを検証した．
サンプルプログラム\verb#pl0a.p#，\verb#pl0b.p#，\verb#pl0c.p#は\verb#PL-0#として正しい文法で書かれたプログラムである．
それ以外のサンプルプログラム\verb#pl1a.p#，\verb#pl2a.p#，\verb#pl2b.p#，\verb#pl2c.p#，\verb#pl3a.p#，\verb#pl3b.p#は\verb#PL-0#として正しくないため，エラー行番号および，正しくないトークンを出力されることが期待される．

\subsection{実験結果}
\verb#parser#を用いて，サンプルプログラムが適切にエラーを返すか検証した．結果を次に示す．

\begin{lstlisting}[caption=parserの実行結果,label=lst:ex2:result-pl0a.p]
$./parser samples/pl0a.p
$./parser samples/pl0b.p
$./parser samples/pl0c.p

$./parser samples/pl1a.p
syntax error(3: '(')

$./parser samples/pl2a.p
syntax error(3: 'function')
$./parser samples/pl2b.p
syntax error(3: 'function')
$./parser samples/pl2c.p
syntax error(3: '(')

$./parser samples/pl3a.p
syntax error(2: '[')
$./parser samples/pl3b.p
syntax error(2: '[')
$./parser samples/pl3c.p
syntax error(3: '(')
\end{lstlisting}
となり，予想した通りサンプルプログラム\verb#pl0a.p#，\verb#pl0b.p#，\verb#pl0c.p#はエラー表示されず，
それ以外のサンプルプログラム\verb#pl1a.p#，\verb#pl2a.p#，\verb#pl2b.p#，\verb#pl2c.p#，\verb#pl3a.p#，\verb#pl3b.p#はエラーが発生した．
したがって正しく動作していることがわかった．
\subsection{考察}
この実験では構文解析を行い，正しくない構文が見つかった場合にsyntax error（構文解析エラー）を発生させることができた．\verb#pl1a.p#，\verb#pl1b.p#，\verb#pl1c.p#，\verb#pl2a.p#，\verb#pl3a.p#，\verb#pl3b.p#では，\verb#PL-0#言語ではない構文が含まれているため，それぞれ\verb#function#や\verb#[#等のトークンでエラーが発生していることがわかった．

\verb#yylineno#および\verb#yytext#は，\verb#extern#がある通り，\verb#parser.y#を\verb#yacc#によって解析し，\verb#y.tab.c#および\verb#y.tab.h#中で宣言されている解析中の行番号および解析中のトークンである．エラーが発生した時には，それより先に進まないため，その行およびトークンがエラー発生時の状態になると考えられる．

\verb#PL-0#構文規則は，正しく\verb#parser.c#に記述すると，ソースコード\ref{lst:ex2:result-parser.y-1}に示される結果が表示される．
\begin{lstlisting}[caption=parser.yの構文ルールの結果1,label=lst:ex2:result-parser.y-1]
2 rules never reduced
1 shift/reduce conflict
\end{lstlisting}
まず\verb#2 rules never reduced#という文は構文ルールのうち，2つが絶対に使用されないように作成されている状態を示す．この実験では\verb#PL-1#や\verb#PL-2#等の構文規則が拡張しやすさのためにすでに記載されている\verb#arg_list#がどの規則からも呼び出されていないことがわかる．そのため，このルールを取り除くと，この警告文は消える．

次に\verb#1 shift/reduce conflict#について考察する．この警告文は，構文解析ルールの中で，1つのトークン先読みを行った時点で，shiftするかreduceするか決めることができないルールが1つ存在することを示している．
構文解析ルールを確認すると，ぶら下がりelse問題と呼ばれる有名な問題が残されていることがわかる．
ぶら下がりelse問題とは，\verb#if a==0 then if b == 0 then a:=0 else b:=0#というプログラムが与えられた時，文法的な曖昧性が残されている問題である．このif文は次のような2通りで考えらえる．これをソースコード\ref{lst:ex2:result-parser.y-2}およびソースコード\ref{lst:ex2:result-parser.y-3}に示す．すなわち，else文がどちらのif文につくのかが曖昧なのである．
\verb#yacc#では，この場合ソースコード\ref{lst:ex2:result-parser.y-2}として認識される．
\verb#yacc#は，shiftとreduceのどちらも可能である場合，reduceを優先して行うように実装されているためである．
\begin{lstlisting}[caption=ぶら下がりelse1,label=lst:ex2:result-parser.y-2]
if a==0 then
  if b == 0 then
    a:=0
  else
    b:=0
\end{lstlisting}
\begin{lstlisting}[caption=ぶら下がりelse2,label=lst:ex2:result-parser.y-3]
if a==0 then
  if b == 0 then
    a:=0
else
  b:=0
\end{lstlisting}
\verb#parser.y#に記載されている\verb#if_statement#の部分を削除すると，\verb#1 shift/reduce conflict#は表示されなくなることがわかる．
ruby言語では，if文は\verb#if ... else ... end#というように構文規則を定めているため，ぶら下がりelse問題は絶対に発生しないようになっている．
したがって，\verb#PL-0#言語でも，\verb#if ... then ... else ... end#となるように構文規則を変更することで，この曖昧性は除去できると考えられる．

\section{実験3}
\subsection{目的}
この実験では，記号表を用いてプログラム中で参照した変数が，正しくスコープ内で定義されていることを確認するコードを作成することである．スコープ内とは，変数を宣言したあと，手続き処理が終了するまでの領域を示し，その中であれば変数を参照することができる．コンパイラは正しいプログラムでない場合にはエラーを返すようにしなければならないため，変数が参照できない場合も異常終了するようにプログラムを変更する．のちの実験では，LLVMでこれらの変数を記録した記号表を利用できるように拡張していく．
記号表は，変数名，変数の最新のレジスタ番号，大域変数またはローカル変数の種別を記録する．また，構文解析時に正しく変数の登録，参照，削除ができるようにする．

\subsection{実験方法}
この実験では，まず記号表を取り扱う\verb#symbol_table.c#および\verb#symbol_table.h#のファイルを作成した．\verb#symbol_table.c#は，記号表への変数の追加関数\verb#insert#，参照関数\verb#lookup#，および削除関数\verb#delete#を定義し，ヘッダファイルには，\verb#Scope#を列挙型として定義した．

\verb#Scope#には，\verb#UNDEFINED_VAR#，\verb#LOCAL_VAR#，\verb#GLOBAL_VAR#，\verb#PROC_NAME#，\verb#CONSTANT#を定義した．ここで，\verb#UNDEFINED_VAR#とは，ローカル変数かグローバル変数か現時点で判別できない場合に対象するためのものである．

グローバル変数の定義とローカル変数の定義は同じ構文で行うため，\verb#yacc#での構文解析時に，構文レベルからグローバル変数かローカル変数か区別することができない．したがって，現在手続き内か手続き外かをフラグとして変数で持つことになるのだが，このフラグは記号表にのみに関するものであり，\verb#parser.y#上ではなく\verb#symbol_table.c#上に定義することがカプセル化の点で望ましい．
ゆえに，このフラグは\verb#symbol_table.c#上に定義し，\verb#parser.y#では変数を定義した時点で\verb#insert#関数を種別を\verb#UNDEFINED_VAR#として呼び出す．
\verb#symbol_table.c#の\verb#insert#関数内で，フラグによってローカル変数かグローバル変数のいずれかで記号表に追加するように設計した．

これによって，ソースコードのカプセル化を行ったため，コードの見通しが立てやすくなった．

記号表は，\verb#SymbolTable#型の構造体の配列をスタックとして実装した．
配列の要素数は1024である．動的リストでないため手続きのネストが深くなる，変数が多量になるとオーバーフローを起こす可能性はあるが，実験で取り扱うレベルの要素数であれば問題になることはないと考えられる．利点としては，プログラム自体がシンプルになるため，見通しがよくなると言う点である．
長いコードを実装する必要がある場合は，配列の要素数を多く取得するか，線形リストに変更を行う．
スタックポインタの代わりに，記号表の使用されている領域の個数を示す\verb#symbol_table_length#を導入した．これによって，新たに導入する際には\verb#symbol_table_length#番目に要素を代入すれば良い．

\subsubsection{insert関数}
\verb#insert#関数は，指定された変数名および種別を記号表に新しく挿入する関数である．
スタックの最後の\verb#SymbolTable#構造体の変数名\verb#var_name#メンバおよびレジスタ番号\verb#reg#メンバ，および\verb#scope#メンバを設定する．
変数名は128文字までを想定する．
\verb#scope#メンバは，\verb#UNDEFINED_VAR#を引数として受け取った場合のみ，ローカル変数かグローバル変数かを判断する．
手続きが開始した時に呼び出される場合は，\verb#is_local_variable#を1と設定した．
\verb#insert#関数の全体をソースコード\ref{lst:ex2:symbol_table.c-insert}に示す．

\begin{lstlisting}[caption=insert関数,label=lst:ex2:symbol_table.c-insert]
void insert(char *vn, Scope scope)
{
  int i;
  char *var_name;

  var_name = (char *)malloc(128);
  strcpy(var_name, vn);

  // show action
  fprintf(stderr, "variable \'%s\' inserted!!(%d)\n", var_name, yylineno);
  fprintf(stderr, "--------------------------\n");

  // assignment to table
  symbol_table[symbol_table_length].var_name = var_name;
  symbol_table[symbol_table_length].reg = symbol_table_length + 2;

  if (scope == UNDEFINED_VAR) {
    symbol_table[symbol_table_length].scope = is_local_variable ? LOCAL_VAR : GLOBAL_VAR;
  } else {
    symbol_table[symbol_table_length].scope = scope;
  }

  if (scope == PROC_NAME) {
    is_local_variable = 1;
  }
  symbol_table_length++;

  // show symbol table
  for (i=0;i<symbol_table_length;i++)
  {
    switch (symbol_table[i].scope)
    {
      case GLOBAL_VAR:
        fprintf(stderr, "%d. %s (GLOBAL_VAR, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
        break;

      case LOCAL_VAR:
        fprintf(stderr, "%d. %s (LOCAL_VAR, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
        break;

      case PROC_NAME:
        fprintf(stderr, "%d. %s (PROC_NAME, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
        break;

    }
  }
  fprintf(stderr, "\n");
}
\end{lstlisting}
表示部については，スタックの全ての要素をプリントしている．

\subsubsection{lookup関数}
\verb#lookup#関数は，指定された変数名で記号表から変数を参照する機能をもつ．
引数として\verb#var_name#を受け取り，スタックの最後の要素から順に検索を行う．
発見できた場合はスタックのインデックスを返し，存在しなければ-1を返す．
\verb#lookup#関数のプログラムをソースコート\ref{lst:ex2:symbol_table.c-lookup}に示す．

\begin{lstlisting}[caption=lookup関数,label=lst:ex2:symbol_table.c-lookup]
int lookup(char *vn)
{
  int i;
  fprintf(stderr, "variable \'%s\' looked up!!(%d)\n", vn, yylineno);
  for (i=symbol_table_length-1;i>=0;i--)
  {
    if (strcmp(vn, symbol_table[i].var_name) == 0)
    {
      switch (symbol_table[i].scope)
      {
        case GLOBAL_VAR:
          fprintf(stderr, "%d. %s (GLOBAL_VAR, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
          break;

        case LOCAL_VAR:
          fprintf(stderr, "%d. %s (LOCAL_VAR, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
          break;

        case PROC_NAME:
          fprintf(stderr, "%d. %s (PROC_NAME, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
          break;
      }
      fprintf(stderr, "\n");
      return i;
    }
  }
  return -1;
}
\end{lstlisting}
検索できた場合は，その変数についての情報を出力する．
\subsubsection{delete関数}
\verb#delete#関数は，手続き処理が終了した時点で呼ばれる関数であり，その手続きないで宣言された全てのローカル変数を削除する機能を持つ．
スタックの最後の要素から順に検索を行い，ローカル変数であれば削除し，そうでなければ処理を止める．
\verb#delete#関数のプログラムをソースコート\ref{lst:ex2:symbol_table.c-delete}に示す．
削除する時には，\verb#malloc#関数で確保したメモリを解放することに気をつけて実装を行った．
手続き終了した時に呼び出されるため，\verb#is_local_variable#を0と設定した．
\begin{lstlisting}[caption=delete関数,label=lst:ex2:symbol_table.c-delete]
void delete()
{
  int i;
  SymbolTable target_symbol;
  fprintf(stderr, "deleted!!\n");
  fprintf(stderr, "--------------------------\n");
  while (1) {
    target_symbol = symbol_table[symbol_table_length-1];
    if (target_symbol.scope == LOCAL_VAR)
    {
      free(target_symbol.var_name);
      symbol_table_length --;
    }
    else break;
  }

  is_local_variable = 0;

  // show symbol table
  for (i=0;i<symbol_table_length;i++)
  {
    switch (symbol_table[i].scope)
    {
      case GLOBAL_VAR:
        fprintf(stderr, "%d. %s (GLOBAL_VAR, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
        break;

      case LOCAL_VAR:
        fprintf(stderr, "%d. %s (LOCAL_VAR, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
        break;

      case PROC_NAME:
        fprintf(stderr, "%d. %s (PROC_NAME, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
        break;

    }
  }
  fprintf(stderr, "\n");
}
\end{lstlisting}
関数定義が終わったら，構文解析中に適切な還元時にこれらの関数を呼び出すように\verb#parser.y#を書き換える．書き換え後のプログラムの構文ルール定義部をソースコード\ref{lst:ex3:parser.y}に載せる．
\begin{lstlisting}[caption=parser.y,label=lst:ex3:parser.y]
program
        : PROGRAM IDENT SEMICOLON outblock PERIOD
        ;

outblock
        : var_decl_part subprog_decl_part statement
        ;

var_decl_part
        : /* empty */
        | var_decl_list SEMICOLON
        ;

var_decl_list
        : var_decl_list SEMICOLON var_decl
        | var_decl
        ;

var_decl
        : VAR id_list
        ;

subprog_decl_part
        : subprog_decl_list SEMICOLON
        | /* empty */
        ;

subprog_decl_list
        : subprog_decl_list SEMICOLON subprog_decl
        | subprog_decl
        ;

subprog_decl
        : proc_decl
        ;

proc_decl
        : PROCEDURE proc_name SEMICOLON inblock { delete(); }
        ;

proc_name
        : IDENT { insert($1, PROC_NAME); }
        ;

inblock
        : var_decl_part statement
        ;

statement_list
        : statement_list SEMICOLON statement
        | statement
        ;

statement
        : assignment_statement
        | if_statement
        | while_statement
        | for_statement
        | proc_call_statement
        | null_statement
        | block_statement
        | read_statement
        | write_statement
        ;

assignment_statement
        : IDENT ASSIGN expression { lookup($1); }
        ;

if_statement
        : IF condition THEN statement else_statement
        ;

else_statement
        : ELSE statement
        |
        ;

while_statement
        : WHILE condition DO statement
        ;

for_statement
        : FOR IDENT ASSIGN expression TO expression DO statement
        ;

proc_call_statement
        : proc_call_name
        ;

proc_call_name
        : IDENT{ lookup($1); }
        ;

block_statement
        : SBEGIN statement_list SEND
        ;

read_statement
        : READ LPAREN IDENT RPAREN { lookup($3); }
        ;

write_statement
        : WRITE LPAREN IDENT RPAREN { lookup($3); }
        ;

null_statement
        : /*empty*/
        ;

condition
        : expression EQ expression
        | expression NEQ expression
        | expression LT expression
        | expression LE expression
        | expression GT expression
        | expression GE expression
        ;

expression
        : term
        | PLUS term
        | MINUS term
        | expression PLUS term
        | expression MINUS term
        ;

term
        : factor
        | term MULT factor
        | term DIV factor
        ;

factor
        : var_name
        | NUMBER
        | LPAREN expression RPAREN
        ;

var_name
        : IDENT{ lookup($1); }
        ;

arg_list
        : expression
        | arg_list COMMA expression
        ;

id_list
        : IDENT { insert($1, UNDEFINED_VAR); }
        | id_list COMMA IDENT { insert($3, UNDEFINED_VAR); }

\end{lstlisting}
ソースコード\ref{lst:ex2:makefile}に示された\verb#Makefile#を用いて，\verb#parser#を生成して，サンプルプログラムを実行した．
\subsection{実験結果}
生成された\verb#parser#を用いて，サンプルプログラムを構文解析，記号表の作成の結果をソースコード\ref{lst:ex3:result-pl0a.p}，ソースコード\ref{lst:ex3:result-pl0b.p}，および，ソースコード\ref{lst:ex3:result-pl0c.p}に示す．
\begin{lstlisting}[caption=pl0a.pに対するparserの実行,label=lst:ex3:result-pl0a.p]
$./parser samples/pl0a.p
variable 'n' inserted!!(2)
--------------------------
0. n (GLOBAL_VAR, 2)

variable 'sum' inserted!!(2)
--------------------------
0. n (GLOBAL_VAR, 2)
1. sum (GLOBAL_VAR, 3)

variable 'n' looked up!!(4)
0. n (GLOBAL_VAR, 2)

variable 'sum' looked up!!(5)
1. sum (GLOBAL_VAR, 3)

variable 'n' looked up!!(6)
0. n (GLOBAL_VAR, 2)

variable 'sum' looked up!!(8)
1. sum (GLOBAL_VAR, 3)

variable 'n' looked up!!(8)
0. n (GLOBAL_VAR, 2)

variable 'sum' looked up!!(8)
1. sum (GLOBAL_VAR, 3)

variable 'n' looked up!!(9)
0. n (GLOBAL_VAR, 2)

variable 'n' looked up!!(10)
0. n (GLOBAL_VAR, 2)

\end{lstlisting}
\begin{lstlisting}[caption=pl0b.pに対するparserの実行,label=lst:ex3:result-pl0b.p]

$./parser samples/pl0b.p
variable 'n' inserted!!(2)
--------------------------
0. n (GLOBAL_VAR, 2)

variable 'x' inserted!!(2)
--------------------------
0. n (GLOBAL_VAR, 2)
1. x (GLOBAL_VAR, 3)

variable 'prime' inserted!!(3)
--------------------------
0. n (GLOBAL_VAR, 2)
1. x (GLOBAL_VAR, 3)
2. prime (PROC_NAME, 4)

variable 'm' inserted!!(4)
--------------------------
0. n (GLOBAL_VAR, 2)
1. x (GLOBAL_VAR, 3)
2. prime (PROC_NAME, 4)
3. m (LOCAL_VAR, 5)

variable 'x' looked up!!(6)
1. x (GLOBAL_VAR, 3)

variable 'm' looked up!!(6)
3. m (LOCAL_VAR, 5)

variable 'x' looked up!!(7)
1. x (GLOBAL_VAR, 3)

variable 'x' looked up!!(7)
1. x (GLOBAL_VAR, 3)

variable 'm' looked up!!(7)
3. m (LOCAL_VAR, 5)

variable 'm' looked up!!(7)
3. m (LOCAL_VAR, 5)

variable 'm' looked up!!(8)
3. m (LOCAL_VAR, 5)

variable 'm' looked up!!(8)
3. m (LOCAL_VAR, 5)

variable 'm' looked up!!(9)
3. m (LOCAL_VAR, 5)

variable 'x' looked up!!(10)
1. x (GLOBAL_VAR, 3)

deleted!!
--------------------------
0. n (GLOBAL_VAR, 2)
1. x (GLOBAL_VAR, 3)
2. prime (PROC_NAME, 4)

variable 'n' looked up!!(13)
0. n (GLOBAL_VAR, 2)

variable 'n' looked up!!(14)
0. n (GLOBAL_VAR, 2)

variable 'n' looked up!!(16)
0. n (GLOBAL_VAR, 2)

variable 'x' looked up!!(16)
1. x (GLOBAL_VAR, 3)

variable 'prime' looked up!!(17)
2. prime (PROC_NAME, 4)

variable 'n' looked up!!(18)
0. n (GLOBAL_VAR, 2)

variable 'n' looked up!!(19)
0. n (GLOBAL_VAR, 2)

\end{lstlisting}
\begin{lstlisting}[caption=pl0c.pに対するparserの実行,label=lst:ex3:result-pl0c.p]

$./parser samples/pl0c.p
variable 'n' inserted!!(2)
--------------------------
0. n (GLOBAL_VAR, 2)

variable 'x' inserted!!(2)
--------------------------
0. n (GLOBAL_VAR, 2)
1. x (GLOBAL_VAR, 3)

variable 'i' inserted!!(2)
--------------------------
0. n (GLOBAL_VAR, 2)
1. x (GLOBAL_VAR, 3)
2. i (GLOBAL_VAR, 4)

variable 'prime' inserted!!(3)
--------------------------
0. n (GLOBAL_VAR, 2)
1. x (GLOBAL_VAR, 3)
2. i (GLOBAL_VAR, 4)
3. prime (PROC_NAME, 5)

variable 'm' inserted!!(4)
--------------------------
0. n (GLOBAL_VAR, 2)
1. x (GLOBAL_VAR, 3)
2. i (GLOBAL_VAR, 4)
3. prime (PROC_NAME, 5)
4. m (LOCAL_VAR, 6)

variable 'x' looked up!!(6)
1. x (GLOBAL_VAR, 3)

variable 'm' looked up!!(6)
4. m (LOCAL_VAR, 6)

variable 'x' looked up!!(7)
1. x (GLOBAL_VAR, 3)

variable 'x' looked up!!(7)
1. x (GLOBAL_VAR, 3)

variable 'm' looked up!!(7)
4. m (LOCAL_VAR, 6)

variable 'm' looked up!!(7)
4. m (LOCAL_VAR, 6)

variable 'm' looked up!!(8)
4. m (LOCAL_VAR, 6)

variable 'm' looked up!!(8)
4. m (LOCAL_VAR, 6)

variable 'm' looked up!!(9)
4. m (LOCAL_VAR, 6)

variable 'x' looked up!!(10)
1. x (GLOBAL_VAR, 3)

deleted!!
--------------------------
0. n (GLOBAL_VAR, 2)
1. x (GLOBAL_VAR, 3)
2. i (GLOBAL_VAR, 4)
3. prime (PROC_NAME, 5)

variable 'n' looked up!!(13)
0. n (GLOBAL_VAR, 2)

variable 'n' looked up!!(14)
0. n (GLOBAL_VAR, 2)

variable 'i' looked up!!(16)
2. i (GLOBAL_VAR, 4)

variable 'x' looked up!!(16)
1. x (GLOBAL_VAR, 3)

variable 'prime' looked up!!(17)
3. prime (PROC_NAME, 5)
\end{lstlisting}
これらの結果より，正しく実装されていることが検証できた．
\subsection{考察}
記号表は，コンパイラ作成において重要であると考えられる．この段階で，プログラムの中で参照される変数が適切に宣言されているかのテストにもなっているからである
この実験では実装されていないが，記号表中に存在しない変数を参照した場合，エラーを発生させるエラーハンドリングも行うべきであると考えた．
lookup関数中では現在では-1を返すだけになっているが，この時点で異常終了するプログラムに書き換えれば良い．この書き換え案をソースコード\ref{lst:ex3:symbol_table.c-lookup-2}に示す．これによって，コンパイル時にエラーの発見がしやすくなるというメリットが得られると考えられる．
\begin{lstlisting}[caption=lookup関数,label=lst:ex3:symbol_table.c-lookup-2]
int lookup(char *vn)
{
  int i;
  fprintf(stderr, "variable \'%s\' looked up!!(%d)\n", vn, yylineno);
  for (i=symbol_table_length-1;i>=0;i--)
  {
    if (strcmp(vn, symbol_table[i].var_name) == 0)
    {
      switch (symbol_table[i].scope)
      {
        case GLOBAL_VAR:
          fprintf(stderr, "%d. %s (GLOBAL_VAR, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
          break;

        case LOCAL_VAR:
          fprintf(stderr, "%d. %s (LOCAL_VAR, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
          break;

        case PROC_NAME:
          fprintf(stderr, "%d. %s (PROC_NAME, %d)\n", i, symbol_table[i].var_name, symbol_table[i].reg);
          break;
      }
      fprintf(stderr, "\n");
      return i;
    }
  }
  fprintf(stderr, "invalid reference(%d: \'%s\')\n", s, yylineno, yytext);
  exit(1);
}
\end{lstlisting}

\end{document}
